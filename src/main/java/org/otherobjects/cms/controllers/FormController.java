package org.otherobjects.cms.controllers;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Enumeration;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Locale;import java.util.Map;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import net.sf.cglib.beans.BeanGenerator;import org.apache.commons.beanutils.PropertyUtils;import org.otherobjects.cms.dao.DynaNodeDao;import org.otherobjects.cms.model.DynaNode;import org.otherobjects.cms.types.JcrTypeServiceImpl;import org.otherobjects.cms.types.PropertyDef;import org.otherobjects.cms.types.TypeDef;import org.otherobjects.cms.types.TypeService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.propertyeditors.CustomDateEditor;import org.springframework.context.MessageSource;import org.springframework.util.Assert;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.validation.Validator;import org.springframework.web.bind.ServletRequestDataBinder;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;/** * Controller to process form submission. Only data for types registered in the TypeService is supported. * * @author rich */public class FormController implements Controller{    protected final Logger logger = LoggerFactory.getLogger(getClass());    private DynaNodeDao dynaNodeDao;    private TypeService typeService;    private Validator validator;    private MessageSource messageSource;    @SuppressWarnings("unchecked")    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception    {        Enumeration parameterNames = request.getParameterNames();        logger.error("Query String: ", request.getQueryString());        while (parameterNames.hasMoreElements())        {            String name = (String) parameterNames.nextElement();            logger.error("Parameter: {} = {}", name, request.getParameter(name));        }                try        {            BindingResult errors = null;            // Get form info            String id = request.getParameter("id");            Assert.hasLength(id, "An existing id is required.");            //TODO M2 Type only needed if adding new objects            //String typeName = request.getParameter("ooType");            //Assert.notNull(typeName, "Type must be provided in form data.");            // Load existing object and create a proper bean from the type info            DynaNode persistentDynaNode = dynaNodeDao.get(id);            TypeDef type = typeService.getType(persistentDynaNode.getOoType());            DynaNode dynaNode = createCustomDynaNodeBean(type);            // Copy the persistent data from the data map to the bean style properties            logger.info("Populating existing object: {} ({})", id, type.getName());            copyDynamicProperties(persistentDynaNode, dynaNode);            // Perform validation            errors = bindParameters(dynaNode, request);            validator.validate(dynaNode, errors);            if (!errors.hasErrors())            {                //before saving we need to copy back bean style properties to dynamic data map                copyBeanProperties(dynaNode, persistentDynaNode, type);                // Save new object                dynaNodeDao.save(persistentDynaNode);            }            // We have errors so return error messages            ModelAndView view = new ModelAndView("jsonView");            if (errors != null && errors.getErrorCount() > 0)            {                List<Object> jsonErrors = new ArrayList<Object>();                for (FieldError e : (List<FieldError>) errors.getFieldErrors())                {                    Map<String, String> error = new HashMap<String, String>();                    error.put("id", e.getField());                    error.put("msg", messageSource.getMessage(e, Locale.getDefault()));                    jsonErrors.add(error);                }                view.getModel().put("success", false);                view.getModel().put("errors", jsonErrors);                return view;            }            // All OK...            view.getModel().put("success", true);            view.getModel().put("formObject", persistentDynaNode);            return view;        }        catch (Exception e)        {            ModelAndView view = new ModelAndView("jsonView");            view.getModel().put("success", false);            view.getModel().put("message", e.getMessage());            logger.error("Error saving form data.", e);            return view;        }    }    /**     * use Springs data binding infrastructure with a custom date editor initialised for the default locale     * @param dynaNode     * @param request     */    private BindingResult bindParameters(DynaNode dynaNode, HttpServletRequest request)    {        ServletRequestDataBinder binder = new ServletRequestDataBinder(dynaNode);        binder.registerCustomEditor(java.util.Date.class, new CustomDateEditor(new SimpleDateFormat("dd/MM/yy"), true));        binder.bind(request);        return binder.getBindingResult();    }    private void copyBeanProperties(DynaNode fromNode, DynaNode toNode, TypeDef type)    {        for (Iterator<PropertyDef> it = type.getProperties().iterator(); it.hasNext();)        {            PropertyDef propertyDef = it.next();            try            {                toNode.set(propertyDef.getName(), PropertyUtils.getNestedProperty(fromNode, propertyDef.getName()));            }            catch (Exception e)            {                logger.warn("Couldn't copy property " + propertyDef.getName(), e);            }        }    }    private void copyDynamicProperties(DynaNode fromNode, DynaNode toBean)    {        for (Iterator<String> it = fromNode.getData().keySet().iterator(); it.hasNext();)        {            String property = it.next();            try            {                PropertyUtils.setNestedProperty(toBean, property, fromNode.get(property));            }            catch (Exception e)            {                logger.warn("Couldn't copy property " + property, e);            }        }        toBean.setId(fromNode.getId());        toBean.setPath(fromNode.getPath());        toBean.setCode(fromNode.getCode());    }    private DynaNode createCustomDynaNodeBean(TypeDef type)    {        BeanGenerator beanGenerator = new BeanGenerator();        beanGenerator.setSuperclass(DynaNode.class);        Assert.isInstanceOf(JcrTypeServiceImpl.class, typeService, "Only works if injected typeService is a JcrTypeServiceImpl");        JcrTypeServiceImpl jcrTypeService = (JcrTypeServiceImpl) typeService;        Map<String, Class<?>> jcrClassMappings = jcrTypeService.getJcrClassMappings();        for (Iterator<PropertyDef> it = type.getProperties().iterator(); it.hasNext();)        {            PropertyDef propertyDef = it.next();            Assert.doesNotContain(propertyDef.getName(), ".", "There is currently no mechanism to create nested properties");            beanGenerator.addProperty(propertyDef.getName(), jcrClassMappings.get(propertyDef.getType()));        }        //TODO what do we do about nested properties?        DynaNode dynaNode = (DynaNode) beanGenerator.create();        dynaNode.setOoType(type.getName());        return dynaNode;    }    public DynaNodeDao getDynaNodeDao()    {        return dynaNodeDao;    }    public void setDynaNodeDao(DynaNodeDao dynaNodeDao)    {        this.dynaNodeDao = dynaNodeDao;    }    public TypeService getTypeService()    {        return typeService;    }    public void setTypeService(TypeService typeService)    {        this.typeService = typeService;    }    public void setValidator(Validator validator)    {        this.validator = validator;    }    public void setMessageSource(MessageSource messageSource)    {        this.messageSource = messageSource;    }}